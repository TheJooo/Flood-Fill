### Class: FloodFillFromImage

This is the main class of the program where the flood fill algorithm is implemented, and the user inputs are handled. It contains the main logic for loading the image, filling the area, saving images at each step, and handling the optional deletion of generated images.

#### 1. Static Variables

private static int imageCounter = 0;
private static String imagePrefix = "flood_fill_step_";
private static int pixelsFilled = 0;

- **imageCounter**: Keeps track of how many images have been saved during the flood fill process. Each saved image gets a unique filename by appending this counter.
- **imagePrefix**: The prefix used for all the generated image filenames (e.g., `flood_fill_step_0.png`, `flood_fill_step_1.png`).
- **pixelsFilled**: This variable counts how many pixels have been filled by the flood fill algorithm. It is used to save images every 50 pixels.

#### 2. Function: floodFill

public static void floodFill(BufferedImage image, int startX, int startY, Color newColor) throws IOException

- **Purpose**: This function performs the flood fill algorithm, filling a contiguous region in the image starting from the pixel at `(startX, startY)` with a new color. It also saves the image every time 20 pixels are filled.
  
##### Parameters:
- `BufferedImage image`: The image being processed.
- `int startX`, `startY`: Coordinates of the starting pixel for the flood fill.
- `Color newColor`: The new color used for filling (in this case, **orange**).

##### Steps Inside floodFill:

1. **Get Image Dimensions**:
   int rows = image.getHeight();
   int cols = image.getWidth();
   - These variables hold the dimensions of the image, which are used to check boundary conditions while filling.

2. **Get the Original Color of the Start Pixel**:
   int originalColor = image.getRGB(startX, startY);
   - This stores the color of the pixel at `(startX, startY)`, which is the pixel where the flood fill begins. We need to know the original color so that we can identify which pixels to change.

3. **Check if the Start Pixel is Already the New Color**:
   if (originalColor == newColor.getRGB()) return;
   - If the starting pixel is already the new color (orange), the function returns early, as no filling is needed.

4. **Initialize the Queue for BFS**:
   Queue<int[]> queue = new LinkedList<>();
   queue.add(new int[]{startX, startY});
   image.setRGB(startX, startY, newColor.getRGB());
   pixelsFilled++;
   - A **queue** is initialized to perform a breadth-first search (BFS) to traverse the connected area in the image.
   - The starting pixel `(startX, startY)` is added to the queue and its color is changed to the new color (`orange`).
   - The `pixelsFilled` counter is incremented, as we have filled one pixel.

5. **Save the Image Every 20 Pixels**:
   if (pixelsFilled % 20 == 0) {
       saveImage(image, imagePrefix + imageCounter++ + ".png");
   }
   - Every time `pixelsFilled` reaches a multiple of 20 (i.e., after 20, 40, 60 pixels), the image is saved to a file.

6. **Direction Vectors**:
   int[] dx = {-1, 1, 0, 0};
   int[] dy = {0, 0, -1, 1};
   - These two arrays define the possible directions to move: up, down, left, and right. They are used to explore neighboring pixels.

7. **BFS Loop**:
   while (!queue.isEmpty()) {
       int[] current = queue.poll();
       int x = current[0];
       int y = current[1];
   - The BFS loop continues as long as there are pixels in the queue to process. The current pixel is retrieved from the queue.

8. **Explore Neighboring Pixels**:
   for (int i = 0; i < 4; i++) {
       int newX = x + dx[i];
       int newY = y + dy[i];
   - For each pixel, the algorithm checks its four neighbors (up, down, left, right) using the direction vectors `dx` and `dy`.

9. **Check Boundary and Color Condition**:
   if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && image.getRGB(newX, newY) == originalColor) {
   - This line checks two things:
     - If the new pixel `(newX, newY)` is within the image bounds.
     - If the color of the new pixel matches the original color. If both conditions are met, the pixel is added to the queue for filling.

10. **Fill the Pixel**:
    image.setRGB(newX, newY, newColor.getRGB());
    queue.add(new int[]{newX, newY});
    pixelsFilled++;
    - The color of the pixel is changed to the new color (orange), the pixel is added to the queue, and `pixelsFilled` is incremented.

11. **Save the Image Again Every 20 Pixels**:
    if (pixelsFilled % 20 == 0) {
        saveImage(image, imagePrefix + imageCounter++ + ".png");
    }

12. **Save the Final State**:
    saveImage(image, imagePrefix + imageCounter++ + ".png");
    - When the algorithm finishes, the final state of the image is saved regardless of the number of pixels filled.

#### 3. Function: loadImage

public static BufferedImage loadImage(String filePath) throws IOException

- **Purpose**: This function loads an image from a file on the disk.
- **Input**: `filePath`, which is the path to the image file.
- **Output**: A `BufferedImage` object representing the image.
  
It reads the image using `ImageIO.read()` and returns it as a `BufferedImage` object that will be processed by the flood fill algorithm.

#### 4. Function: saveImage

public static void saveImage(BufferedImage image, String filename) throws IOException

- **Purpose**: This function saves the current state of the image to a file on disk.
- **Input**: The current `BufferedImage` (`image`) and the desired `filename` (e.g., `flood_fill_step_0.png`).
  
It writes the image to a PNG file using `ImageIO.write()`.

#### 5. Function: deleteGeneratedImages

public static void deleteGeneratedImages() {
    for (int i = 0; i < imageCounter; i++) {
        File file = new File(imagePrefix + i + ".png");
        if (file.exists()) {
            file.delete();
        }
    }
    System.out.println("All generated images have been deleted.");
}

- **Purpose**: This function deletes all the images generated during the flood fill process.
- **Operation**: It loops through all the generated image files (`flood_fill_step_X.png`), checks if the file exists, and deletes it.
  
After deletion, it prints a confirmation message.

#### 6. Main Method

public static void main(String[] args) throws IOException {
    if (args.length < 3) {
        System.out.println("Usage: java FloodFillFromImage <image-path> <start-x> <start-y>");
        return;
    }

    String imagePath = args[0];
    int startX = Integer.parseInt(args[1]);
    int startY = Integer.parseInt(args[2]);

    BufferedImage image = loadImage(imagePath);

    System.out.println("Starting Flood Fill...");
    floodFill(image, startX, startY, Color.ORANGE);

    System.out.println("Flood Fill complete.");

    Scanner scanner = new Scanner(System.in);
    System.out.println("Do you want to delete all generated images? (yes/no)");
    String response = scanner.nextLine().trim().toLowerCase();

    if (response.equals("yes")) {
        deleteGeneratedImages();
    } else {
        System.out.println("Images have been kept.");
    }
    scanner.close();
}

- **Input Arguments**: 
  - `args[0]`: Path to the input image.
  - `args[1]`: x-coordinate of the starting point.
  - `args[2]`: y-coordinate of the starting point.
  
- The image is loaded using `loadImage`, and the flood fill process begins at the specified `(startX, startY)` coordinates with the color **orange**.
  
- After the flood fill completes, the user is asked if they want to delete all the generated images. If the user responds with `yes`, the images are deleted; otherwise, they are kept.
